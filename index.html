<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Record"><meta name="keywords" content=""><meta name="author" content="SayMe"><meta name="copyright" content="SayMe"><title>SayMeeveTime | SayMe</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="SayMe" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">SayMe</div><div class="author-info__description text-center">Record</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">14</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SayMe</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">SayMe</div><div id="site-sub-title">SayMeeveTime</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/06/Linux%E5%91%BD%E4%BB%A4/">Linux命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-06</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/linux/">linux</a></span><div class="content"><h4 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">rpm </span><br><span class="line">	主选项</span><br><span class="line">	-i  安装</span><br><span class="line">    -e   卸载</span><br><span class="line">    -U  升级</span><br><span class="line">    -q   查找</span><br><span class="line">    辅助选项</span><br><span class="line">     v  显示过程</span><br><span class="line">     -h   --hash</span><br><span class="line">     查询</span><br><span class="line">     -a -all   查询所有安装的包</span><br><span class="line">     -f --file  查询拥有&lt;--file&gt;的包</span><br><span class="line">     -p  查询一个没有安装的包</span><br><span class="line">     </span><br><span class="line">     卸载</span><br><span class="line">      --nodeps     忽略依赖</span><br><span class="line">      </span><br><span class="line">      rpm -ql   rpm包      #  查看包安装到哪里了 </span><br><span class="line">      </span><br><span class="line">      非官方提供的由别人基于源码打包,安全无法保证  (就像Windows上你下载的  .exe 可能是别人打包好的留了后门程序)</span><br><span class="line">      rpm包一般比较旧,除非官方提供</span><br><span class="line">      rpm依赖问题比较致命</span><br></pre></td></tr></table></figure>

<h4 id="Yum"><a href="#Yum" class="headerlink" title="Yum"></a>Yum</h4><p>​    Yum客户端  : 从yum仓库下载软件包并安装</p>
<p>​    Yum仓库:  存储大量RPM软件包通过FTP|HTTP|HTTPS|file方式共享软件包</p>
<p>特点:</p>
<p>​    自动解决依赖</p>
<p>​    自动下包</p>
<p>​    自动安装</p>
<p>FTP|HTTP|HTTPS|file    四种协议 共同点  都支持下载业务</p>
<p>ftp 根目录   /var/ftp </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd			#启动ftp  需要先安装</span><br><span class="line">mount /dev/cdrom  /var/ftp/pub      # 将有rpm包的光盘挂载到Linux上</span><br></pre></td></tr></table></figure>

<p>如何配置yum源</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line"><span class="meta">#</span><span class="bash">可以先将原来的移动到一个其他的目录 然后再编写自己的yum源</span></span><br><span class="line">vim xxx.repo   # 写自己的yum源	</span><br><span class="line">内容如下:</span><br><span class="line">		name=test    # yum源的名称</span><br><span class="line">		baseurl=ftp://localhost/pub   #地址</span><br><span class="line">		gpgcheck:0    #是否检测</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用其他网上的yum源(清华  阿里 EPEL)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/yum.conf    # 查看yum配置文件</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h4 id="分区-fdisk"><a href="#分区-fdisk" class="headerlink" title="分区             fdisk"></a>分区             fdisk</h4><pre><code> [root@Zhaomo0823 ~]# fdisk /dev/vda 
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help): m
Command action</code></pre>
<p>   a   toggle a bootable flag<br>   b   edit bsd disklabel<br>   c   toggle the dos compatibility flag<br>   d   delete a partition     #删除分区<br>   g   create a new empty GPT partition table<br>   G   create an IRIX (SGI) partition table<br>   l   list known partition types     # 分区类型<br>   m   print this menu<br>   n   add a new partition           #新建分区<br>   o   create a new empty DOS partition table<br>   p   print the partition table            #打印分区表<br>   q   quit without saving changes            #不保存退出<br>   s   create a new empty Sun disklabel<br>   t   change a partition’s system id    #更改分区系统id  设置交换分区<br>   u   change display/entry units<br>   v   verify the partition table<br>   w   write table to disk and exit              #保存退出<br>   x   extra functionality (experts only)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): </span><br></pre></td></tr></table></figure>



<p> fdisk  是一个创建和维护分区表的程序,它兼容DOS类型的分区表 BSD或者SUN 类型的磁盘列表<br>    fdisk -l /dev/sdb    # 查看本机下磁盘挂载情况</p>
<h4 id="ps-静态任务管理器"><a href="#ps-静态任务管理器" class="headerlink" title="ps    静态任务管理器"></a>ps    静态任务管理器</h4><p>top  动态任务管理器 </p>
<p>kill   杀死单个进程</p>
<p>killall    杀死一个进程树</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps </span><br></pre></td></tr></table></figure>

<p>线程优先级</p>
<p>nice     设置进程的优先级    </p>
<p>​        优先级默认为10 </p>
<p>renice      更改进程的优先级 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nice  --19 ping -c 500 localhost     -19优先级</span><br><span class="line">nice  -19 ping -c 500 localhost        19优先级</span><br><span class="line">	优先级 -20  到 19   数字越小优先级越大</span><br><span class="line">nice -n 8 ping localhost      # 以8 的优先级执行ping命令</span><br><span class="line">renice -n 18 进程id    调整进程的优先级   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">renice   -n 9 -u  root    #  修改root用户优先级为9</span><br></pre></td></tr></table></figure>

<h4 id="密码文件"><a href="#密码文件" class="headerlink" title="密码文件"></a>密码文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd  </span><br><span class="line"><span class="meta"> 	#</span><span class="bash"> 具体参数含义谷歌就行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/etc/shadow       #目前只读文件一般也不修改  需要修改要加权 </span><br><span class="line">    #    可以查看到密码  sub512 加密</span><br><span class="line">    </span><br><span class="line">    #参数解释</span><br><span class="line">    	用户名</span><br><span class="line">    	口令(密码)</span><br><span class="line">    	最后一次修改的时间: 标识从某一时刻起到用户最后一次修改口令的天数</span><br><span class="line">    	最小时间间隔: 两次修改口令之间的最小天数</span><br><span class="line">    	最大时间间隔: 口令保持有效的最多天数,即多少天后必须修改口令</span><br><span class="line">    	警告时间: 从系统开始警告到口令正式失效的天数</span><br><span class="line">    	不活动时间: 口令过期多少天后,该账号被禁用</span><br><span class="line">    	失效时间:指示口令失效的绝对天数(从1970年1月1日开始计算)</span><br><span class="line">    	标志: 未使用</span><br></pre></td></tr></table></figure>

<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">chmod    #  修改文件的访问权限</span><br><span class="line">	命令语法 </span><br><span class="line">	chmod [options]  mode file ....</span><br><span class="line">	命令选项</span><br><span class="line">	-R  递归设置权限,针对目录有效</span><br><span class="line">	</span><br><span class="line">	mode  谁给什么权限</span><br><span class="line">	u (所有者)  g(所属组)  o(其他人)  a(所有人)</span><br><span class="line">	</span><br><span class="line">	+ - =</span><br><span class="line">	权限 r  读  w 写  x 执行   </span><br><span class="line">	</span><br><span class="line"> chmod g+w, o-r 文件名    #  给组加上写权限   其他人减去读的权限</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod 4755  /bin/systemctl      #以所有者的身份去执行此用户本不能执行的命令</span><br><span class="line"></span><br><span class="line">chmod 2755 /doc      # 文件夹下继承下新建的子文件夹或者子文件继承父文件夹的属组</span><br><span class="line">chmod 1755 /opt/public/    # 公共目录  设置黏连位(谁建的谁删)</span><br></pre></td></tr></table></figure>

<p>详细看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ftl1012/p/9260157.html">Linux 文件特殊权限详解</a></p>
<p>ACL 权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setfacl:      #设置权限 </span><br><span class="line">	setfacl -m user:用户名:rwx 文件名</span><br><span class="line">	setfacl -m group:组名:rw 文件名</span><br><span class="line"></span><br><span class="line">getfacl   # 获取权限</span><br><span class="line">	getfacl 文件名</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stat  文件名    #  查看文件信息  </span><br><span class="line"></span><br><span class="line">[root@Zhaomo0823 zhaomo]# stat 2.jpg </span><br><span class="line">  File: ‘2.jpg’</span><br><span class="line">  Size: 5513      	Blocks: 16         IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d	Inode: 1317455     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2020-12-30 11:45:06.000000000 +0800</span><br><span class="line">Modify: 2020-12-30 11:30:57.000000000 +0800</span><br><span class="line">Change: 2020-12-30 11:45:06.580375982 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>

<h4 id="数据检索"><a href="#数据检索" class="headerlink" title="数据检索"></a>数据检索</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep  </span><br><span class="line">	-e   相当于 egrep</span><br><span class="line">	.....</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grep -r  &quot;root&quot;  /etc       #  查看/etc文件下包含root 字符串的文件</span><br><span class="line">grep -r -l  &quot;root&quot;  /etc       #  查看/etc文件下包含root 字符串的文件 只显示文件名</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><pre><code> 上一个命令的输出到下一个命令的输入</code></pre>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | head -2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sort    #  排序命令</span><br><span class="line"></span><br><span class="line">sort -n  num | uniq -d      # 显示重复的</span><br><span class="line">sort -n  num | uniq -u      # 去掉重复的</span><br><span class="line"></span><br><span class="line">想去重 先排序</span><br><span class="line"></span><br><span class="line">diff      #  比较是否相同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wc  文件名         # 统计命令</span><br></pre></td></tr></table></figure>

<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum list NetworkManager     </span><br><span class="line">systemctl status NetworkManager</span><br><span class="line">yum install -y NetworkManager</span><br><span class="line">systemctl status NetworkManager</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>nmtui             文本界面下的用户界面内</p>
<p>nmcli             命令行设置</p>
<p>nm-connection-editor        图形界面设置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">nmtui     #  启动NetworkManager</span><br><span class="line">需要执行systemctl start NetworkManager</span><br><span class="line"></span><br><span class="line">nmcli     #  不知道命令可以  按二次Tab</span><br><span class="line"></span><br><span class="line">nmcli   networking off   #  关闭网络</span><br><span class="line">nmcli   networking on    #  开启网络</span><br><span class="line"></span><br><span class="line">cat /etc/hostname </span><br><span class="line">nmcli general logging      # 查看登录级别</span><br><span class="line">journalctl 				#查看网络日志</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nmcli  </span><br><span class="line">	connection</span><br><span class="line">	device </span><br><span class="line">	general</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ifconfig  </span><br><span class="line">systemctl restart network </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nmcli connection edit 网卡名   #交互模式编辑网卡</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/djlsunshine/p/9733182.html">linux中nmcli命令使用及网络配置</a></p>
<h4 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find / -name passwd   </span><br><span class="line">find / -empty          #查看所有空文件或空文件</span><br><span class="line"></span><br><span class="line">find / -maxdepth 2 -name passwd    #查看目录层级2层的 name   passwd 的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find / -mindepth 2 -name passwd    #从第几级开始查</span><br></pre></td></tr></table></figure>

<p>按文件类型查询</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">find / -type p</span><br><span class="line">	f   普通文件</span><br><span class="line">	d   目录问价</span><br><span class="line">	l	符号链接文件</span><br><span class="line">	b	块设备文件</span><br><span class="line">	c	字符设备文件</span><br><span class="line">	p	管道文件</span><br><span class="line">	s 	套接字文件</span><br><span class="line"> </span><br><span class="line">find /  -atime -3     # 三天之内访问过的</span><br><span class="line"></span><br><span class="line">   以天为单位</span><br><span class="line">   mtime   修改时间</span><br><span class="line">   atime   访问时间</span><br><span class="line">   ctime   创建时间</span><br><span class="line">   </span><br><span class="line">   以分钟为单位</span><br><span class="line">   _mmin</span><br><span class="line">   _amin  </span><br><span class="line">   </span><br><span class="line">find / -name passwd -exec tar rvf  passwd.tar &#123;&#125; \;     #  找到名字 passwd的执行压缩  压缩为 passwd.tar </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">locate   模糊查找   查找的是Linux系统每天特定时间自动索引备份到系统数据库中的文件</span><br><span class="line">   -i   </span><br><span class="line">   </span><br><span class="line">    mlocate.db    #  </span><br></pre></td></tr></table></figure>

<h4 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">压缩                                                                     解压</span><br><span class="line">tar -cvzf  etc.tar.gz  /etc 									tar xvzf etc.tar.gz</span><br><span class="line">tar -cjvf etc.tar.bz2 /etc										tar -jvxf etc.tar.bz2</span><br><span class="line">tar -cvJf etc.tar.xz /etc    									tar -Jvxf etc.tar.xz</span><br><span class="line">tar -cvf etc.tar /etc											tar xvf etc.tar</span><br><span class="line"></span><br><span class="line">加-   命令顺序不改变    不加  会自动排顺序  推荐不加  </span><br><span class="line"></span><br><span class="line">ll -h  查看文件夹下文件   以大小展示</span><br></pre></td></tr></table></figure>

<p>bzip  文件</p>
<p>bunzip  解压</p>
<p>gzip     压缩</p>
<p>gunzip     解压</p>
<p>zcat  压缩文件名</p>
<p>zip   xxx.zip    xxx   将xxx文件压缩为xxx.zip </p>
<p>unzip   解压缩</p>
<h4 id="用户删除及属性修改"><a href="#用户删除及属性修改" class="headerlink" title="用户删除及属性修改"></a>用户删除及属性修改</h4><h3 id="用户删除"><a href="#用户删除" class="headerlink" title="用户删除"></a>用户删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">userdel userxx     #只删除用户</span><br><span class="line">ls /home    #  在这个下面还有只删除用户的文件夹</span><br><span class="line">	rm -rf /home/userxxx    # 需要再执行这个命令</span><br><span class="line">	rm -rf /var/mail/userxxx    #  再执行这个</span><br><span class="line"></span><br><span class="line">userdel -r userxx      #删除用户及其关联文件夹</span><br><span class="line"></span><br><span class="line">vim /etc/default/useradd    #如果新建用户没有指定一些选项    会有默认的组和默认/home目录和邮箱</span><br><span class="line">/etc/login.defs   #shadow 密码套件配置</span><br></pre></td></tr></table></figure>

<h5 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">usermod - modify a user account </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">语法</span></span><br><span class="line">usermod </span><br><span class="line">		-a  --append</span><br><span class="line">        -L 	--lock</span><br><span class="line">        -U	--unlock</span><br><span class="line">        -m  --move-home with-d</span><br><span class="line">        </span><br><span class="line">usermod -m -d /home/user01 user01   # 将user01 的家目录移动到/home/user01</span><br><span class="line">usermod -G root -a user01   # 将user01添加到root用户组</span><br></pre></td></tr></table></figure>

<h5 id="更改用户"><a href="#更改用户" class="headerlink" title="更改用户"></a>更改用户</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man  chage  # 查看用法  了解即可</span><br><span class="line"></span><br><span class="line">chage user01 			#修改密码年龄</span><br></pre></td></tr></table></figure>

<h4 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">groupadd      	 # 新建组 </span><br><span class="line">	-g, --gid GID    #指定GID</span><br><span class="line">	-r, --system     #创建一个系统组</span><br><span class="line">	-o,--non-unique    #此选项允许添加一个使用非唯一GID的组</span><br><span class="line">groupdel       	#删除组</span><br><span class="line">groupmod     	 #修改组属性</span><br><span class="line">gppasswd        #组密码</span><br></pre></td></tr></table></figure>



<p>详细看<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38136194">三分钟教你理清Linux 用户与用户组关系</a> </p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef </span><br><span class="line">uptime      # 服务器运行时间</span><br><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://www.linuxidc.com/Linux/2016-07/133515.htm">Linux下ps -ef和ps aux的区别</a></p>
<p>中病毒  查进程   杀进程    </p>
<p>重装  加补丁</p>
<p>单核的使用率  100%    多核  n* 100%s</p>
<h4 id="Linux服务"><a href="#Linux服务" class="headerlink" title="Linux服务"></a>Linux服务</h4><p>什么是服务 ?</p>
<p>服务三要素</p>
<p>服务的分类                6和7       一个采用 systemV   串行启动              systemd  并行启动</p>
<p>独立服务       非独立服务</p>
<p>独立服务:  运行在内存中,服务响应速度快,占用更多内存.    常驻内存 监听状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/systemd/system     服务启动脚本存放目录</span><br><span class="line"></span><br><span class="line">启动管理脚本</span><br><span class="line">ls  /usr/lib/systemd/system</span><br></pre></td></tr></table></figure>

<p>xnited  服务</p>
<h4 id="Shell字符"><a href="#Shell字符" class="headerlink" title="Shell字符"></a>Shell字符</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls  x?   #  匹配   x后面任一字符的文件</span><br><span class="line">	X*   #  匹配后面出现多个字符</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">~     #      直接回到home目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">expr   1+1   #  计算1+1</span><br><span class="line">expr   1 \* 1    #1乘1</span><br></pre></td></tr></table></figure>







</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">动态代理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-04</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AOP/">AOP</a></span><div class="content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">AOP：【动态代理】</span><br><span class="line"> * 		指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式；</span><br><span class="line"> * </span><br><span class="line"> * <span class="number">1</span>、导入aop模块；Spring AOP：(spring-aspects)</span><br><span class="line"> * <span class="number">2</span>、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）</span><br><span class="line"> * <span class="number">3</span>、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；</span><br><span class="line"> * 		通知方法：</span><br><span class="line"> * 			前置通知(<span class="meta">@Before</span>)：logStart：在目标方法(div)运行之前运行</span><br><span class="line"> * 			后置通知(<span class="meta">@After</span>)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）</span><br><span class="line"> * 			返回通知(<span class="meta">@AfterReturning</span>)：logReturn：在目标方法(div)正常返回之后运行</span><br><span class="line"> * 			异常通知(<span class="meta">@AfterThrowing</span>)：logException：在目标方法(div)出现异常以后运行</span><br><span class="line"> * 			环绕通知(<span class="meta">@Around</span>)：动态代理，手动推进目标方法运行（joinPoint.procced()）</span><br><span class="line"> * <span class="number">4</span>、给切面类的目标方法标注何时何地运行（通知注解）；</span><br><span class="line"> * <span class="number">5</span>、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;</span><br><span class="line"> * <span class="number">6</span>、必须告诉Spring哪个类是切面类(给切面类上加一个注解：<span class="meta">@Aspect</span>)</span><br><span class="line"> * [<span class="number">7</span>]、给配置类中加 <span class="meta">@EnableAspectJAutoProxy</span> 【开启基于注解的aop模式】</span><br><span class="line"> * 		在Spring中很多的 <span class="meta">@EnableXXX</span>;</span><br><span class="line"> * </span><br><span class="line"> * 三步：</span><br><span class="line"> * 	<span class="number">1</span>）、将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（<span class="meta">@Aspect</span>）</span><br><span class="line"> * 	<span class="number">2</span>）、在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）</span><br><span class="line"> *  <span class="number">3</span>）、开启基于注解的aop模式；<span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"> *  </span><br><span class="line"> * AOP原理：【看给容器中注册了什么组件，这个组件什么时候工作，这个组件的功能是什么？】</span><br><span class="line"> * 		<span class="meta">@EnableAspectJAutoProxy</span>；</span><br><span class="line"> * <span class="number">1</span>、<span class="meta">@EnableAspectJAutoProxy</span>是什么？</span><br><span class="line"> * 		<span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span>：给容器中导入AspectJAutoProxyRegistrar</span><br><span class="line"> * 			利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion</span><br><span class="line"> * 			internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line"> * </span><br><span class="line"> * 		给容器中注册一个AnnotationAwareAspectJAutoProxyCreator；</span><br><span class="line"> * </span><br><span class="line"> * <span class="number">2</span>、 AnnotationAwareAspectJAutoProxyCreator：</span><br><span class="line"> * 		AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line"> * 			-&gt;AspectJAwareAdvisorAutoProxyCreator</span><br><span class="line"> * 				-&gt;AbstractAdvisorAutoProxyCreator</span><br><span class="line"> * 					-&gt;AbstractAutoProxyCreator</span><br><span class="line"> * 							implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</span><br><span class="line"> * 						关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory</span><br><span class="line"> * </span><br><span class="line"> * AbstractAutoProxyCreator.setBeanFactory()</span><br><span class="line"> * AbstractAutoProxyCreator.有后置处理器的逻辑；</span><br><span class="line"> * </span><br><span class="line"> * AbstractAdvisorAutoProxyCreator.setBeanFactory()-》initBeanFactory()</span><br><span class="line"> * </span><br><span class="line"> * AnnotationAwareAspectJAutoProxyCreator.initBeanFactory()</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * 流程：</span><br><span class="line"> * 		<span class="number">1</span>）、传入配置类，创建ioc容器</span><br><span class="line"> * 		<span class="number">2</span>）、注册配置类，调用refresh（）刷新容器；</span><br><span class="line"> * 		<span class="number">3</span>）、registerBeanPostProcessors(beanFactory);注册bean的后置处理器来方便拦截bean的创建；</span><br><span class="line"> * 			<span class="number">1</span>）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor</span><br><span class="line"> * 			<span class="number">2</span>）、给容器中加别的BeanPostProcessor</span><br><span class="line"> * 			<span class="number">3</span>）、优先注册实现了PriorityOrdered接口的BeanPostProcessor；</span><br><span class="line"> * 			<span class="number">4</span>）、再给容器中注册实现了Ordered接口的BeanPostProcessor；</span><br><span class="line"> * 			<span class="number">5</span>）、注册没实现优先级接口的BeanPostProcessor；</span><br><span class="line"> * 			<span class="number">6</span>）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中；</span><br><span class="line"> * 				创建internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】</span><br><span class="line"> * 				<span class="number">1</span>）、创建Bean的实例</span><br><span class="line"> * 				<span class="number">2</span>）、populateBean；给bean的各种属性赋值</span><br><span class="line"> * 				<span class="number">3</span>）、initializeBean：初始化bean；</span><br><span class="line"> * 						<span class="number">1</span>）、invokeAwareMethods()：处理Aware接口的方法回调</span><br><span class="line"> * 						<span class="number">2</span>）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）</span><br><span class="line"> * 						<span class="number">3</span>）、invokeInitMethods()；执行自定义的初始化方法</span><br><span class="line"> * 						<span class="number">4</span>）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）；</span><br><span class="line"> * 				<span class="number">4</span>）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；--》aspectJAdvisorsBuilder</span><br><span class="line"> * 			<span class="number">7</span>）、把BeanPostProcessor注册到BeanFactory中；</span><br><span class="line"> * 				beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line"> * =======以上是创建和注册AnnotationAwareAspectJAutoProxyCreator的过程========</span><br><span class="line"> * </span><br><span class="line"> * 			AnnotationAwareAspectJAutoProxyCreator =&gt; InstantiationAwareBeanPostProcessor</span><br><span class="line"> * 		<span class="number">4</span>）、finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作；创建剩下的单实例bean</span><br><span class="line"> * 			<span class="number">1</span>）、遍历获取容器中所有的Bean，依次创建对象getBean(beanName);</span><br><span class="line"> * 				getBean-&gt;doGetBean()-&gt;getSingleton()-&gt;</span><br><span class="line"> * 			<span class="number">2</span>）、创建bean</span><br><span class="line"> * 				【AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor，会调用postProcessBeforeInstantiation()】</span><br><span class="line"> * 				<span class="number">1</span>）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；</span><br><span class="line"> * 					只要创建好的Bean都会被缓存起来</span><br><span class="line"> * 				<span class="number">2</span>）、createBean（）;创建bean；</span><br><span class="line"> * 					AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例</span><br><span class="line"> * 					【BeanPostProcessor是在Bean对象创建完成初始化前后调用的】</span><br><span class="line"> * 					【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象的】</span><br><span class="line"> * 					<span class="number">1</span>）、resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation</span><br><span class="line"> * 						希望后置处理器在此能返回一个代理对象；如果能返回代理对象就使用，如果不能就继续</span><br><span class="line"> * 						<span class="number">1</span>）、后置处理器先尝试返回对象；</span><br><span class="line"> * 							bean = applyBeanPostProcessorsBeforeInstantiation（）：</span><br><span class="line"> * 								拿到所有后置处理器，如果是InstantiationAwareBeanPostProcessor;</span><br><span class="line"> * 								就执行postProcessBeforeInstantiation</span><br><span class="line"> * 							<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">								bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">							&#125;</span><br><span class="line"> * </span><br><span class="line"> * 					<span class="number">2</span>）、doCreateBean(beanName, mbdToUse, args);真正的去创建一个bean实例；和<span class="number">3.6</span>流程一样；</span><br><span class="line"> * 					<span class="number">3</span>）、</span><br><span class="line"> * 			</span><br><span class="line"> * 		</span><br><span class="line"> * AnnotationAwareAspectJAutoProxyCreator【InstantiationAwareBeanPostProcessor】	的作用：</span><br><span class="line"> * <span class="number">1</span>）、每一个bean创建之前，调用postProcessBeforeInstantiation()；</span><br><span class="line"> * 		关心MathCalculator和LogAspect的创建</span><br><span class="line"> * 		<span class="number">1</span>）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）</span><br><span class="line"> * 		<span class="number">2</span>）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，</span><br><span class="line"> * 			或者是否是切面（<span class="meta">@Aspect</span>）</span><br><span class="line"> * 		<span class="number">3</span>）、是否需要跳过</span><br><span class="line"> * 			<span class="number">1</span>）、获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】</span><br><span class="line"> * 				每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；</span><br><span class="line"> * 				判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回<span class="keyword">true</span></span><br><span class="line"> * 			<span class="number">2</span>）、永远返回<span class="keyword">false</span></span><br><span class="line"> * </span><br><span class="line"> * <span class="number">2</span>）、创建对象</span><br><span class="line"> * postProcessAfterInitialization；</span><br><span class="line"> * 		<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<span class="comment">//包装如果需要的情况下</span></span><br><span class="line"> * 		<span class="number">1</span>）、获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors</span><br><span class="line"> * 			<span class="number">1</span>、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）</span><br><span class="line"> * 			<span class="number">2</span>、获取到能在bean使用的增强器。</span><br><span class="line"> * 			<span class="number">3</span>、给增强器排序</span><br><span class="line"> * 		<span class="number">2</span>）、保存当前bean在advisedBeans中；</span><br><span class="line"> * 		<span class="number">3</span>）、如果当前bean需要增强，创建当前bean的代理对象；</span><br><span class="line"> * 			<span class="number">1</span>）、获取所有增强器（通知方法）</span><br><span class="line"> * 			<span class="number">2</span>）、保存到proxyFactory</span><br><span class="line"> * 			<span class="number">3</span>）、创建代理对象：Spring自动决定</span><br><span class="line"> * 				JdkDynamicAopProxy(config);jdk动态代理；</span><br><span class="line"> * 				ObjenesisCglibAopProxy(config);cglib的动态代理；</span><br><span class="line"> * 		<span class="number">4</span>）、给容器中返回当前组件使用cglib增强了的代理对象；</span><br><span class="line"> * 		<span class="number">5</span>）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；</span><br><span class="line"> * 		</span><br><span class="line"> * 	</span><br><span class="line"> * 	<span class="number">3</span>）、目标方法执行	；</span><br><span class="line"> * 		容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）；</span><br><span class="line"> * 		<span class="number">1</span>）、CglibAopProxy.intercept();拦截目标方法的执行</span><br><span class="line"> * 		<span class="number">2</span>）、根据ProxyFactory对象获取将要执行的目标方法拦截器链；</span><br><span class="line"> * 			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"> * 			<span class="number">1</span>）、List&lt;Object&gt; interceptorList保存所有拦截器 <span class="number">5</span></span><br><span class="line"> * 				一个默认的ExposeInvocationInterceptor 和 <span class="number">4</span>个增强器；</span><br><span class="line"> * 			<span class="number">2</span>）、遍历所有的增强器，将其转为Interceptor；</span><br><span class="line"> * 				registry.getInterceptors(advisor);</span><br><span class="line"> * 			<span class="number">3</span>）、将增强器转为List&lt;MethodInterceptor&gt;；</span><br><span class="line"> * 				如果是MethodInterceptor，直接加入到集合中</span><br><span class="line"> * 				如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；</span><br><span class="line"> * 				转换完成返回MethodInterceptor数组；</span><br><span class="line"> * </span><br><span class="line"> * 		<span class="number">3</span>）、如果没有拦截器链，直接执行目标方法;</span><br><span class="line"> * 			拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制）</span><br><span class="line"> * 		<span class="number">4</span>）、如果有拦截器链，把需要执行的目标对象，目标方法，</span><br><span class="line"> * 			拦截器链等信息传入创建一个 CglibMethodInvocation 对象，</span><br><span class="line"> * 			并调用 Object retVal =  mi.proceed();</span><br><span class="line"> * 		<span class="number">5</span>）、拦截器链的触发过程;</span><br><span class="line"> * 			<span class="number">1</span>)、如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-<span class="number">1</span>大小一样（指定到了最后一个拦截器）执行目标方法；</span><br><span class="line"> * 			<span class="number">2</span>)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；</span><br><span class="line"> * 				拦截器链的机制，保证通知方法与目标方法的执行顺序；</span><br><span class="line"> * 		</span><br><span class="line"> * 	总结：</span><br><span class="line"> * 		<span class="number">1</span>）、  <span class="meta">@EnableAspectJAutoProxy</span> 开启AOP功能</span><br><span class="line"> * 		<span class="number">2</span>）、 <span class="meta">@EnableAspectJAutoProxy</span> 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line"> * 		<span class="number">3</span>）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；</span><br><span class="line"> * 		<span class="number">4</span>）、容器的创建流程：</span><br><span class="line"> * 			<span class="number">1</span>）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象</span><br><span class="line"> * 			<span class="number">2</span>）、finishBeanFactoryInitialization（）初始化剩下的单实例bean</span><br><span class="line"> * 				<span class="number">1</span>）、创建业务逻辑组件和切面组件</span><br><span class="line"> * 				<span class="number">2</span>）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程</span><br><span class="line"> * 				<span class="number">3</span>）、组件创建完之后，判断组件是否需要增强</span><br><span class="line"> * 					是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；</span><br><span class="line"> * 		<span class="number">5</span>）、执行目标方法：</span><br><span class="line"> * 			<span class="number">1</span>）、代理对象执行目标方法</span><br><span class="line"> * 			<span class="number">2</span>）、CglibAopProxy.intercept()；</span><br><span class="line"> * 				<span class="number">1</span>）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）</span><br><span class="line"> * 				<span class="number">2</span>）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；</span><br><span class="line"> * 				<span class="number">3</span>）、效果：</span><br><span class="line"> * 					正常执行：前置通知-》目标方法-》后置通知-》返回通知</span><br><span class="line"> * 					出现异常：前置通知-》目标方法-》后置通知-》异常通知</span><br><span class="line"> * 		</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAOP</span> </span>&#123;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//业务逻辑类加入容器中</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MathCalculator <span class="title">calculator</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MathCalculator();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//切面类加入到容器中</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LogAspects <span class="title">logAspects</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LogAspects();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-15</time><div class="content"><h5 id="单一职责原则注意事项和细节"><a href="#单一职责原则注意事项和细节" class="headerlink" title="单一职责原则注意事项和细节"></a>单一职责原则注意事项和细节</h5><p>降低类的复杂度,一个类只负责一项职责.</p>
<p>提高类的可读性,可维护性</p>
<p>降低变更引起的风险</p>
<p>通常情况下,我们应当遵守单一职责原则,只有逻辑足够简单,才可以在代码级违反单一职责原则;只有类中方法数量足够少,才可以在方法级别保持单一职责原则.</p>
<p>接口和抽象层都是加缓存     可以是耦合度降低且继承或实现能更易扩展</p>
<p>组合比继承降低耦合性       依赖  聚合  组合方式来替换继承 </p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/06/14/HashMap%E5%92%8CHashTable/">HashMap和HashTable</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-14</time><div class="content"><p>考察目标:</p>
<ul>
<li>集合体系结构是否熟悉</li>
<li>JDk版本更新是否了解</li>
</ul>
<p>题目分析:</p>
<ul>
<li>相同点<ul>
<li>都是双列集合,一个键对应一个值</li>
<li>都是键不能重复,但是值可以重复</li>
</ul>
</li>
<li>不同点<ul>
<li>出现版本的区别<ul>
<li>HashMap是 JDK 1.2 版本出现的</li>
<li>HashTable是JDK1.0版本出现的</li>
</ul>
</li>
<li>线程同步的区别<ul>
<li>HashMap是线程不同步的</li>
<li>HashTable是线程同步的</li>
</ul>
</li>
<li>存储数据的区别<ul>
<li>HashMap可以存储null键和null值</li>
<li>HashTable不可以存储null键和null值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>双列集合优先使用HashMap集合</li>
<li>如果是在多线程场景下,也无需使用HashTable集合,我们可以使用ConcurrentHashMap集合,这个是线程同步的.</li>
<li>HashTable 集合虽然使用不多,但是它有一个给力的子类,Properties集合还在大量使用中,一般配合IO流来加载配置文件.</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/27/hexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">hexo使用笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-27</time><div class="content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装  </span><br><span class="line">npm update hexo -g #升级  </span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure>

<h2 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h2><p><code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code> #新建文章<br><code>hexo p</code> == <code>hexo publish</code><br><code>hexo g</code> == <code>hexo generate</code>#生成<br><code>hexo s</code> == <code>hexo server</code> #启动服务预览<br><code>hexo d</code> == <code>hexo deploy</code>#部署</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`hexo server` 		<span class="comment">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class="line">`hexo server -s` <span class="comment">#静态模式</span></span><br><span class="line">`hexo server -p 5000` <span class="comment">#更改端口</span></span><br><span class="line">`hexo server -i 192.168.1.1` <span class="comment">#自定义 IP</span></span><br><span class="line"></span><br><span class="line">`hexo clean` <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">`hexo g` 	<span class="comment">#生成静态网页</span></span><br><span class="line">`hexo d` 	<span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure>



<h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`hexo generate` 		<span class="comment">#使用 hexo生成静态文件快速而且简单</span></span><br><span class="line">`hexo generate --watch` <span class="comment">#监视文件变动</span></span><br></pre></td></tr></table></figure>



<h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><blockquote>
<p>两个命令的作用是相同的<br><code>hexo generate --deploy</code><br><code>hexo deploy --generate</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy -g</span><br><span class="line">hexo server -g</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/25/Some/">Some</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-25</time><div class="content"><h4 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h4><p>解决方案一:触发器</p>
<p>​        注意使用触发器实现是将业务绑定到了数据库端,在进行系统设计时要确认方案</p>
<p>解决方案二: 业务层删除操作分别调用两个模块的删除功能</p>
<p>​        注意删除主使用ID删除,删除从使用按关联ID 删除</p>
<p>​        注意删除的顺序,先删从,后删主</p>
<p>解决方案三: 存储过程</p>
<p>​        整套的疏忽层解决方案,没有单一功能使用的.</p>
<p>解决方案四: 依赖框架提供得到级联删除功能</p>
<p>解决方案五:  定时维护/垃圾数据清理</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String    final 修饰不可变长度<br>StringBuffer    1.0   线程安全(同步)<br>Stringbuilder   1.5 线程不安全</p>
<p>SQL拼接语句内容较少   用String即可<br>如果语句内容很多   应该使用StringBuillder</p>
<h4 id="解决中文乱码的一个思路"><a href="#解决中文乱码的一个思路" class="headerlink" title="解决中文乱码的一个思路"></a>解决中文乱码的一个思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String fileName = <span class="keyword">new</span> String(<span class="string">&quot;测试文件名.xlsx&quot;</span>.getBytes(),<span class="string">&quot;iso8859-1&quot;</span>);</span><br><span class="line">然后再传fileName 过去</span><br></pre></td></tr></table></figure>



<h4 id="权限系统是一种设定用户与可操作模块之间关系的系统"><a href="#权限系统是一种设定用户与可操作模块之间关系的系统" class="headerlink" title="权限系统是一种设定用户与可操作模块之间关系的系统"></a>权限系统是一种设定用户与可操作模块之间关系的系统</h4><p>通过设定用户与可操作性的模块之间的关系,控制用户在可指定范围进行业务执行</p>
<p>基于用户的权限控制(UBAC: User-Based Access Control)</p>
<p>基于角色的权限控制(RBAC :Role-Based Access Control)</p>
<h4 id="TCP发送数据如何设置发送多大数据"><a href="#TCP发送数据如何设置发送多大数据" class="headerlink" title="TCP发送数据如何设置发送多大数据?"></a>TCP发送数据如何设置发送多大数据?</h4><p>如果数据拆包发送如何保证数据顺序?</p>
<p>​    根据接收到的Seq和ACK,将发送和接收的数据进行排序’</p>
<p>无论是Seq还是ACK,都是针对”对方”而言的.是<strong>对方发送的数据和对方接收到的数据</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/03/28/%E9%9A%8F%E8%AE%B0/">随记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-28</time><div class="content"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##Docker</span></span><br><span class="line">01/07</span><br><span class="line">停止所有容器   docker stop $(docker ps -a -q)</span><br><span class="line">刪除所有容器   docker  rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line">删除所有容器   docker ps -a -q|xargs docker rm </span><br><span class="line"></span><br><span class="line">docker rmi -f 容器id 容器id 容器id <span class="comment">#删除多个容器</span></span><br><span class="line">docker rmi -f $(docker images -aq) <span class="comment">#删除全部镜像</span></span><br><span class="line">Ctrl+P+Q	<span class="comment"># 容器不停止退出    如果启动时忘了后台启动的话  </span></span><br><span class="line"></span><br><span class="line">docker start 容器id		</span><br><span class="line">docker restart 容器id</span><br><span class="line">docker stop 容器id</span><br><span class="line">docker <span class="built_in">kill</span> 容器id		<span class="comment"># 强制停止当前容器</span></span><br></pre></td></tr></table></figure>


<p>​    </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 89c5b9c81e74(mysql 容器id)  bash</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it 58ff53c77659 bash</span><br><span class="line"></span><br><span class="line">ps -ef | grep java</span><br></pre></td></tr></table></figure>


<p>​<br>    mvn package -Dmaven.test.skip=true</p>
<h4 id="20210427"><a href="#20210427" class="headerlink" title="20210427"></a>20210427</h4><p> 内存 </p>
<pre><code> 线性地址空间       运行程序和指令的数据</code></pre>
<p>内核</p>
<pre><code>kernel   进不了系统  拔出内存条  用橡皮擦 擦完放进去  先加载内核  shell    Tomcat   Redis  等 </code></pre>
<p>内核开了保护模式     内核态        用户态 </p>
<p> 总的来说，就是线程切换或者加锁解锁都是因为需要用户态和内核态的切换，从而导致的开销大。 应用程序的执行需要依托内核提供的资源，包括CPU、存储、IO等，因此内核提供了一个统一的接口， 也就是系统调用，一个应用程序从用户态进入到内核态，就需要执行系统调用。 用户态转化为内核态时，需要执行系统调用，保存现场，也就是保存用户态的寄存器等， 然后去系统调用，并在内核态执行，最后恢复现场。并且由于内核对于用户的不信任， 因此内核需要对用户进行一些额外的检查，这就需要耗费更多的工作了</p>
<p>prop 获取和 attr获取值区别</p>
<p>0  标准输入文件          键盘<br>1  标准输出文件         显示器<br>2  标准错误输出文件        显示器</p>
<p>shell 输出重定向</p>
<blockquote>
<p>代表覆盖  &gt;&gt; 代表追加<br>如果不想把命令的输出结果保存到文件,也不想把命令的输出结果显示到屏幕上,干扰命令的执行,可以把命令的所有结果重定向到/dev/null 文件中<br> ls -l &amp;&gt;/dev/null</p>
</blockquote>
<p>springboot项目刚导入pom 文件 看是否构建ok   可以在命令行 输入 mvn clean  install  进行构建  没问题 则证明项目搭建ok</p>
<p> 迁入  直接选择控件  分页自适应 不用处理    然后 那个事件冲突了要进行处理 </p>
<h4 id="20200925"><a href="#20200925" class="headerlink" title="20200925"></a>20200925</h4><p>API  Application Programming Interface的缩写 中文意义就是应用程序接口<br>XML 可扩展标记语言,是一种程序与程序之间传输数据的标记语言<br>JSON 英文javascript object notation的缩写,是一种轻量级数据交换格式.</p>
<p>YML  YAML Aint Markup Language  不仅是标记语言  </p>
<p>RESTFul 具体含义   </p>
<p>英文Representational State Transfer缩写<br>中文意思是”表现层状态转化”</p>
<p>curl  Linux中访问网址</p>
<p>curl <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>     直接访问一个网页</p>
<p>curl -i <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>    显示HTTP response的头信息</p>
<p>curl -v <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a><br>curl  -trace output.txt <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>    显示一次HTTP请求的通信过程</p>
<p>curl -x GET/POST/PUT/DELETE <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>   CURL 执行各种请求</p>
<p>ls /dev   查看某一文件下的文件<br>ls -dl /etc   -d 查看目录 (不查看里面的内容)</p>
<p>-S  以文件的大小进行排序 </p>
<p>ls -lS /boot   查看boot文件夹下的文件并按倒序排序<br>ls -lSh /boot   查看boot文件夹下的文件并按倒序排序     文件单位增加可读性</p>
<p>初始化显示 :<br>        先内存中做 更新多次  一次性全部再到页面 减少页面更新的次数<br>        内存中更新好了之后  再挂载到页面 </p>
<p>更新:  beforeupdate   update</p>
<p>死亡:<br>    和RN不同  页面还展示  但是不会交互  </p>
<p>MySQL  安全性<br>    grant select on 数据库名.*  to  用户名<br>    revoke select on  数据库名.*  from 用户名</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/03/28/SQL%E4%BC%98%E5%8C%96/">SQL优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-28</time><div class="content"><p>MySQL本地路径/data/mysql<br>    索引文件就是func.MYI</p>
<p>MySql子查询  exists  </p>
<p>select bo.*<br>From boys bo<br>where NOT exists (<br>    select boyfriend_id<br>    from beauty b<br>    where bo.id = b.boyfriend_id<br>};    </p>
<p>select 查询列表            7           执行顺序<br>from 表                1<br>连接类型 join 表2        2<br>on   连接条件            3<br>where  筛选条件            4<br>group by  分组列表        5<br>having  分组后的筛选        6<br>order by  排序列表        8<br>limit 偏移,条目数        9</p>
<p>优化第一条<br>1.全职匹配我最爱<br>2.最佳左前缀法则   联合索引要连续<br>3.不在索引上做任何操作(计算 函数(自动or手动)类型转换),会导致索引失效而转向全表扫描<br>4.存储引擎不能使用索引中范围条件右边的列<br>    建一个索引 三行的  第二行使用了范围匹配 那么最后那个就用不上了</p>
<p>5.尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少select *<br>6.mysql在使用不等于(!=或者&lt;&gt;)的时候无法使用索引会导致全表扫描<br>7.is null,is not null也无法使用索引<br>8.like 以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作</p>
<p>9.字符串不加单引号索引失效<br>   结合第三条 不要进行类型转换<br>10.少用 or 用它连接时会索引失效</p>
<p>定值 范围还是排序,一般order by 是给个范围<br>group by基本上都需要进行排序,会有临时表产生</p>
<p>一般性建议:<br>    对于 单键索引,尽量选择针对当前query过滤性更好的索引<br>    在选择组合索引的时候,当前query中过滤性最好的字段在索引字段顺序中,位置越靠前越好<br>    在选择组合索引的时候,尽量选择可以能够包含当前query中的where字句中更多字段的索引<br>    尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</p>
<p>SQL支持两种方式的排序,FileSort和Index,Index效率高,<br>指MySQL扫描索引本身完成排序.FileSort方式效率较低<br>    Order by满足两种情况会使用Index方式排序:<br>        Order by语句使用索引最左前列<br>        使用where字句与Order by字句条件排列组合满足索引最左前列</p>
<p>双路排序:<br>    MySQL4.1 之前是使用双路排序,字面意思就是二次扫描磁盘,最终得到数据,<br>读取行指针和orderby列,对他们进行排序,然后扫描已经排序好的列表,按照列表中的值重新从列表中读取对应的数据输出<br>从磁盘读取排序字段,在buffer进行排序,再从磁盘取其他字段</p>
<p>取一批数据,要对磁盘进行了两次扫描,众所周知,I\O是很耗时的,所以在mysql4.1之后,出现了第二种改进的算法,就是单路排序<br>单路排序:<br>    从磁盘读取查询需要的所有列,按照order by列在buffer对它们进行排序,然后扫描排序后的列表进行输出,它的效率更快一些,<br>避免了第二次读取数据.并且把随机IO变成了顺序IO,但是它会使用更多的空间.</p>
<p>结论及引申出的问题:<br>    由于单路是后出的,总体而言好过双路<br>    但是单路有问题<br>        在sort_buffer,方法B比方法A要占用很多空间,因为方法B是把所有字段都取出,所以有可能取出的数据的总大小<br>    超出了sort_buffer 的容量,导致每次只能取sort_buffer容量大小的数据,进行排序(创建tmp文件,多路合并),排完再取<br>    sort_buffer容量大小,再排……从而多次IO.</p>
<pre><code>本来想省一次I\O操作,反而导致了大量的I\O操作反而得不偿失.</code></pre>
<p>提高Order By的速度<br>    1.Order by时select * 是一个大忌只query需要的字段,这点非常重要.在这里的影响是:<br>        1.1 当Query的字段大小总和小于max_length_for_sort_data而且排序字段不是Text|BLOB类型的时候,会用<br>        改进的算法—–单路排序,否则用老算法—-多路排序.<br>        1.2两种算法的数据都有可能超出sort_buffer的容量,超出之后,会创建tmp文件进行合并排序,导致多次I\O<br>        ,但是使用单路排序算法的风险会更大一些,所以要提高sort_buffer_size.</p>
<pre><code>2.尝试提高sort_buffer_size
    不管用那种算法,提高这个参数都会提高效率,当然,要根据系统的能力去提高,因为这个参数是针对每个进程
    的
3.尝试提高max_lengyh_for_-sort_data
    提高这个参数,会增加用改进算法的概率,但是如果设的太高,数据总容量超出sort_buffer_size的概率就增大,
    明显症状是高的磁盘I\O活动和低的处理器使用率.</code></pre>
<p>Group by 实质是先排序后进行分组,遵照索引建的最佳左前缀<br>    当无法使用索引列,增大max_length_for_sort_data参数的设置+ 增大sort_buffer_size参数的设置<br>    where高于having,能写在where限定的条件就不要去having限定了.</p>
<p>MySQL的慢查询日志是MySQL提供的一种日志记录,它用来记录MySQL中响应时间超过阈值的语句,具体指运行时间超过long_query_time<br>值的SQL,则会被记录到慢查询日志中.</p>
<p>long_query_time的默认值为10,意思是运行10秒以上的语句</p>
<p>通过慢查询日志来查看哪些SQL超过我们的最大忍耐时间值,然后通过修改慢SQL定义的阈值,结合explain进行全面分析</p>
<p>默认情况下,MySQL数据库没有开启慢查询日志,需要我们手动来设置这个参数.<br>当然,如果不是调优需要的话,一般不建议启动该参数,因为开启慢查询日志或多或少带来一定的性能影响.慢查询日志支持将日志记录写入文件</p>
<p>Show Profile  </p>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制.</p>
<p>在数据库中,除传统的计算资源(如 CPU RAM I/O等)的争用以外,数据也是一种供许多用户共享的资源.如何保证数据并发访问的一致性 有效性是所有数据库必须解决的一个问题,锁冲突也是影响数据库并发访问性能的一个重要因素.从这个角度来说,锁对 数据库而言显得尤其重要,也更加复杂.</p>
<p>lock table mylock read,book write;</p>
<p>MyISAm在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行增删改操作之前,会自动给涉及的表加写锁.<br>MySQL的表级锁有两种模式<br>    表共享读锁(Table Read Lock)<br>    表独占写锁(Table Write Lock)</p>
<p>1.对MyISAM表的读操作(加读锁),不会阻塞其他进程对同一表的读请求,但会阻塞对同一表的写请求.只有当2020/07/31读锁释放后,才会执行其他进程的写操作.<br>2.对MyISAM表的写操作(加写锁),会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其他进程的读写操作.<br>    简而言之:就是读锁会阻塞写,但是不会阻塞读,而写锁则会把读和写都堵塞. </p>
<p>Myisam的读写调度是写优先,这也是myisam不适合做写为主表的引擎,因为写锁后,其他线程不能做任何操作,大量的更新会使查询很难得到锁,从而造成永远阻塞.</p>
<p>索引失效行锁变表锁<br>   注意这里的where条件 b=4005 。要记得当前表的b字段是字符串类型，并且加了索引，加了索引之后如果查询条件没加引号会导致失效<br>    varchar 类型记得加单引号   不然 本来innodb是行锁  你操作第四行  我操作第九行 互不影响  但是因为操作varchar类型的值没有加单引号  导致行锁变表锁   另一个会话操作另外一行数据时被锁定</p>
<p>间隙锁危害<br>  什么是间隙锁<br>    当我们用范围条件而不是相等条件检索数据,并请求共享或排他锁,innodb会给出复合条件的已有数据记录的索引项加锁;对于键值在条件范围内但不存在的记录,叫做”间隙(GAP)”,<br>    Innodb也会对这个”间隙”加锁,这种锁机制就是所谓的间隙锁(Next-Key锁).<br>  危害<br>    因为Query执行过程中通过过范围查找的话,它会锁定整个范围内所有的索引键值,即使这个键值不存在.<br>    间隙锁有一个比较致命的弱点,就是当锁定一个范围键值之后,即使某些不存在的键值也会无辜的锁定,而造成在锁定的时候无法插入锁定键值范围内的任何数据.在某些场景下这可能会对性能造成很大的危害.</p>
<p> 如何锁定一行:<br>    begin;<br>    select * from test_innodb_lock where a = 8  for update;<br>    commit;<br>    锁定某一行后,其他操作会被阻塞,直到锁定的行提交commit.</p>
<p>行锁总结:<br>    innodb存储引擎由于实现了行级锁定,虽然在锁定机制的方面所带来的的性能损耗可能要比表级锁定会要高一些,但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的.当系统并发量较高的时候,innodb的整体性能和MyISAM相比就会有比较明显的优势了.<br>    但是,innodb的行级锁定同样也有其脆弱的一面,当我们使用不当的时候,可能会让innodb的整体性能不仅不能比MyISAM高,甚至可能会更差.</p>
<p>行锁优化建议:<br>    尽可能让所有数据都通过索引来完成,避免无索引行锁升级为表锁.<br>    合理设计索引,尽可能缩小锁的范围<br>    尽可能较少检索条件,避免间隙锁<br>    尽量控制事务大小,减少锁定资源量和时间长度<br>    尽可能低级别事务隔离.<br>页锁:<br>    开销和加锁时间界于表锁和行锁之间,会出现思索哦;锁定粒度界于表锁和行锁之间,并发度一般.</p>
<p>主从复制主机my,ini修改:<br>    1:两个MySQL  版本尽可能一致  一个Windows 一个Linux  同一网段  可以ping通<br>    2.1:设置主服务器唯一ID   server-id = 1<br>    2.2: 启用二进制日志<br>        log-bin = 自己本地的路径/mysqlbin<br>        log-err = 自己本地的路径/mysqlerr<br>    2.3:根目录<br>        basedir = “自己本地路径到MySQL版本即可”<br>    2.4:临时目录<br>        tmpdir = “自己本地路径到MySQL版本即可”<br>    2.5:数据目录<br>        datadir = “自己本地路径到/Data/“</p>
<pre><code>read-only = 0;</code></pre>
<p>主从复制从机my.cnf修改:<br>    注释掉 server-id  =1   打开 server-id  =2<br>在Windows主句上建立账户并授权给slave<br>    GRANT REPLICATION SLAVE ON <em>.</em> TO ‘zhaomo’ @’从机器数据库ip’ IDENTIFIED BY ‘123456’;<br>    flush privileges;</p>
<p>查看主机状态:<br>    show master status;<br>    记下结果中的file和position的值<br>从机命令行:<br>    change master to master_host =’ip’,<br>    master_user=’zhaomo’<br>    master_password=’123456’<br>    master_log_file=’mysqlbin.具体数字’,master_log_pos=具体值;</p>
<pre><code>start slave; 

show slave status\G
    需要看到:
        Slave_IO_Running: Yes
        Slave_SQL_Running: Yes
第一次配置不成功的话 要在主机上重新查看    show master status; 获取最新的结果中的file和position的值</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/03/28/shell/">shell</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-28</time><div class="content"><h1 id="千峰Shell"><a href="#千峰Shell" class="headerlink" title="千峰Shell"></a>千峰Shell</h1><p>程序   解决问题’</p>
<p>编程  写代码</p>
<p>shell   Linux系统自带的语言</p>
<p>机器语言   010101</p>
<p>汇编语言      英文010101</p>
<p>高级语言    编译型   ====编译 ===计算机  跨平台性能  执行速度快</p>
<p>​                    解释型 ====解释器 ===编译 计算机  跨平台性强,执行速度快   虚拟机  python Java  PHP  Ruby</p>
<p>1./etc/profile   无论哪个用户登录</p>
<p>2./etc/bashrc  Centos  bash执行时</p>
<p>3.~/.profile      bash以login方式执行    /bash_login  图像模式下 将会被读取</p>
<p>4.~/.bash_login   bash登录时执行  </p>
<p>5.~/.bash_profile    bash已login方式登录 时   读取 </p>
<p>6.~/.bashrc</p>
<p>7.~/.bash_logout     bash登出时 </p>
<p>环境变量加载</p>
<p>图形化界面登录时    1 3 </p>
<p> 图像化界面登录后,打开终端时:   2 6</p>
<p>文本界面登录时    2 1 5 </p>
<p>su 用户切换  2 1 5 </p>
<p>​     不加参数   2 6</p>
<p>bash特性   </p>
<pre><code>1. 自动补全 功能 
 2. 历史命令功能
 3. 别名
 4. 快捷键
 5. 前后台作业控制
 6. 清除dead会话
 7. 输入输出重定向
 8. 命令排序
 9. 通配符</code></pre>
<h6 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h6><p>Ctrl +A  命令首</p>
<p>Ctrl +E  命令尾</p>
<p>Ctrl +C  终止</p>
<p>Ctrl +U   删除或剪切光标之前</p>
<p>Ctrl + K    删除或剪切光标之后</p>
<p>Ctrl  + Y  粘贴 Ctrl + U 和 Ctrl +K  的内容</p>
<p>Ctrl +  R  在历史命令中搜索 ,按下Ctrl + R之后,就会出现搜索界面,输入内容在历史命令中搜索 </p>
<p>Ctrl +D   退出当前终端</p>
<p>Ctrl + Z 暂停  并放入后台 ,这个快捷键牵扯工作管理内容</p>
<p>Ctrl +S  暂停屏幕输出 </p>
<p>Ctrl + Q 恢复屏幕输出</p>
<p>前后端作业控制</p>
<p>Linux bash shell  单一终端界面下,经常需要管理或同时完成多个作业,如一边执行编译,一边实现数据备份,以及执行SQL查询等其他任务,所有的上述的这些工作可以在一个bash内实现,在同一个终端窗口完成</p>
<ol>
<li><p>前后台作业的定义</p>
<ol>
<li>前后台作业实际上对应的的也就是前后台进程,因此也就有对应的pid,在这里统称为作业</li>
<li>无论是前台作业还是后台作业,两者都来自当前的Shell.是当前shell的子程序</li>
<li>前台作业:可以由用户参与交互及控制的作业我们称为前台作业</li>
<li>后台作业: 在内存可以自运行的作业,用户无法参与与交互以及使用 Ctrl +  C 来终止,只能通过bg或fg来调用该作业.</li>
</ol>
</li>
<li><p>几个常用的作业命令</p>
<ol>
<li>command  &amp;  直接让作业进入后台运行     yum -y install sl     sl &amp; </li>
<li>Ctrl  + Z  将当前作业切换到后台</li>
<li>jobs  查看后台作业状态</li>
<li>fg % n  让后台运行的作业n切换到前台来</li>
<li>bg  % n  让指定的作业n在后台运行</li>
<li>kill % n   杀死指定的作业</li>
</ol>
<p>通过jobs 方式管理作业,当前终端的作业在其他终端不可见</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/03/28/IDEA%E5%85%B3%E8%81%94%E4%B8%80%E5%88%87/">IDEA关联一切</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-28</time><div class="content"><p>IDEA关联一切</p>
<p>​    IDEA 中 Spring 关联  </p>
<p>Spring   Facets  </p>
<p>与数据关联</p>
<p>​    </p>
<p>调试  debug</p>
<p>​    F8 逐行运行    </p>
<p>F9直接跳下个断点   没有就直接执行完 </p>
<p>shift  + Ctrl  + F8 </p>
<p>禁止所有断点    mute  Breakpoints    忽略所有断电  然后按  F9</p>
<p>遍历一个集合  当size 大于3  时  加断点</p>
<p>Ctrl  shift  +F8    条件断点  </p>
<p>运行到指定行   </p>
<p>debug  控制台直接修改值  </p>
<p>Ctrl +shift +F9    在加 @Test 内运行  此测试</p>
<p>shift  +F9     再次运行刚才运行的程序 </p>
<p>文件Copy   F5     </p>
<p>文件移动   F6</p>
<p>只要文件名    Ctrl  +  C</p>
<p>完整路径  CTRL  + Shift  +  C</p>
<p>CTRL  Shift  +V  调出剪贴板  </p>
<p>CTRL +  F12  查看本类中方法</p>
<p>CTRL +  H   类继承关系</p>
<p>CTRL  + AlT +  H      main函数继承关系</p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By SayMe</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>